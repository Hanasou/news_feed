package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/Hanasou/news_feed/go/common/auth"
	"github.com/Hanasou/news_feed/go/gateway/graph/model"
)

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	var username, userId string
	if !r.Config.Debug {
		// Require authentication for viewing todos
		claims, err := auth.GetClaimsFromContext(ctx)
		if err != nil {
			return nil, fmt.Errorf("authentication required: %w", err)
		}

		// Log the authenticated user (for debugging)
		fmt.Printf("User %s (%s) is requesting todos\n", claims.Username, claims.UserID)
		username = claims.Username
		userId = claims.UserID
	} else {
		username = "debug-username"
		userId = "debug-user-id"
	}
	// TODO: Implement actual todo fetching logic
	// For now, return a sample todo
	return []*model.Todo{
		{
			ID:    "1",
			Text:  fmt.Sprintf("Sample todo for user %s", username),
			Done:  false,
			UserD: userId, // Using UserD field as defined in the model
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// These checks make code less readable and more cumbersome
	// Figure out a better way to do this
	// TODO: This is not secure, config file can get tampered with.
	// Get this value from env variable or vault
	if !r.Config.Debug {
		// Require admin role for viewing all users
		claims, err := auth.GetClaimsFromContext(ctx)
		if err != nil {
			return nil, fmt.Errorf("authentication required: %w", err)
		}

		userRole, err := auth.GetUserRoleFromContext(ctx)
		if err != nil {
			return nil, fmt.Errorf("user role not found: %w", err)
		}

		if userRole != "admin" {
			return nil, fmt.Errorf("admin access required")
		}
		return []*model.User{
			{
				ID:   claims.UserID,
				Name: claims.Username,
			},
		}, nil
	} else {
		// Return list of users without check
		return []*model.User{
			{
				ID:   "debug_id",
				Name: "debug_name",
			},
		}, nil
	}

	// TODO: Implement actual user fetching logic
	// For now, return a sample user list

}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
